// Node JS script to generate a TS file containing const enums of SMuFL glyphs and codepoints.
// Usage: node smufl_const_enum.js

// The original data is here: https://raw.githubusercontent.com/w3c/smufl/gh-pages/metadata/glyphnames.json

// Read in glyphnames.json into a JS object.
const fs = require('fs');
const path = require('path');
const glyphNames = JSON.parse(fs.readFileSync(path.join(__dirname, 'config', 'glyphnames.json'), 'utf8'));

let glyphs = '';
let codePoints = '';

for (let n in glyphNames) {
  const glyphInfo = glyphNames[n];

  // Add quotes around keys like: 4stringTabClef & 6stringTabClef.
  const startsWithDigit = /^\d/;
  if (startsWithDigit.test(n)) {
    n = `'${n}'`;
  }

  // Translate the codepoint to a hex number (instead of strings of the format U+E06E).
  if (glyphInfo.codepoint) {
    const hex = glyphInfo.codepoint.slice(2).toLowerCase();
    codePoints += `\n  ${n} = 0x${hex},`;

    // If the codepoint is greater than 0xFFFF, we need to add braces.
    if (hex.length > 4) {
      glyphs += `\n  ${n} = '\\u{${hex}}',`;
    } else {
      // Otherwise, use the regular unicode escape.
      glyphs += `\n  ${n} = '\\u${hex}',`;
    }
  }

  if (glyphInfo.alternateCodepoint) {
    const hex = glyphInfo.alternateCodepoint.slice(2).toLowerCase();
    codePoints += `\n  ${n}Alternate = 0x${hex},`;
    // If the codepoint is greater than 0xFFFF, we need to add braces.
    if (hex.length > 4) {
      glyphs += `\n  ${n}Alternate = '\\u{${hex}}',`;
    } else {
      // Otherwise, use the regular unicode escape.
      glyphs += `\n  ${n}Alternate = '\\u${hex}',`;
    }
  }
}

const output = `// This file is generated by \`smufl_const_enum.js\`.
export const enum SMuFLGlyph {${glyphs}\n}\n
export const enum SMuFLCodePoint {${codePoints}\n}\n`;

// Save the output to vexflow/src/smufl.ts.

fs.writeFileSync(path.join(__dirname, '../../src/smufl.ts'), output, 'utf8');

console.log('Writing to vexflow/src/smufl.ts.');
